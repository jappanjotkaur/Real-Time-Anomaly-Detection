<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetSniff Guard - Real-time Network Monitor</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 20px 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 5px;
        }

        .header p {
            color: #666;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card h3 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-card.anomaly .value {
            color: #e74c3c;
        }

        .stat-card.rate .value {
            color: #f39c12;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .chart-card h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .packets-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .packets-section h2 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .packets-table {
            width: 100%;
            border-collapse: collapse;
            max-height: 400px;
            overflow-y: auto;
            display: block;
        }

        .packets-table thead {
            background: #667eea;
            color: white;
            position: sticky;
            top: 0;
        }

        .packets-table th,
        .packets-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .packets-table tbody tr:hover {
            background: #f5f5f5;
        }

        .anomaly-badge {
            background: #e74c3c;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .normal-badge {
            background: #27ae60;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .flow-score {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }

        .flow-score-low {
            background: #d4edda;
            color: #155724;
        }

        .flow-score-medium {
            background: #fff3cd;
            color: #856404;
        }

        .flow-score-high {
            background: #f8d7da;
            color: #721c24;
        }

        .alerts-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .alerts-section h2 {
            color: #e74c3c;
            margin-bottom: 15px;
        }

        .alert-item {
            background: #fff3cd;
            border-left: 4px solid #f39c12;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .alert-item.critical {
            background: #f8d7da;
            border-left-color: #e74c3c;
        }

        .alert-timestamp {
            color: #666;
            font-size: 0.9em;
            font-weight: bold;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #27ae60;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #e74c3c;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        canvas {
            max-height: 300px;
        }
    </style>
</head>
<body>
    <div class="connection-status">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Connected</span>
    </div>

    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è NetSniff Guard - Real-time Network Monitor</h1>
            <p>Advanced packet capture and anomaly detection system</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <h3>Total Packets</h3>
                <div class="value" id="totalPackets">0</div>
            </div>
            <div class="stat-card anomaly">
                <h3>Anomaly Packets</h3>
                <div class="value" id="anomalyPackets">0</div>
            </div>
            <div class="stat-card rate">
                <h3>Anomaly Rate</h3>
                <div class="value" id="anomalyRate">0%</div>
            </div>
            <div class="stat-card">
                <h3>Runtime</h3>
                <div class="value" id="runtime">00:00</div>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-card">
                <h2>üìä Protocol Distribution</h2>
                <canvas id="protocolChart"></canvas>
            </div>
            <div class="chart-card">
                <h2>üìà Packet Rate (Last 60 min)</h2>
                <canvas id="rateChart"></canvas>
            </div>
        </div>

        <div class="packets-section">
            <h2>üì¶ Recent Packets (Last 50)</h2>
            <div style="overflow-x: auto;">
                <table class="packets-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Time</th>
                            <th>Source</th>
                            <th>Destination (Website)</th>
                            <th>Protocol</th>
                            <th>Service/Port</th>
                            <th>Size</th>
                            <th>Status</th>
                            <th>Threat</th>
                        </tr>
                    </thead>
                    <tbody id="packetsTable">
                        <tr>
                            <td colspan="10" style="text-align: center; color: #999;">Waiting for packets...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="alerts-section">
            <h2>‚ö†Ô∏è Recent Alerts</h2>
            <div id="alertsList">
                <p style="color: #999;">No alerts yet</p>
            </div>
        </div>
    </div>

    <script>
        // Socket.IO connection
        const socket = io();

        // Statistics
        let stats = {
            totalPackets: 0,
            anomalyPackets: 0,
            anomalyRate: 0,
            runtime: 0
        };

        // Protocol chart
        let protocolData = {};
        const protocolCtx = document.getElementById('protocolChart').getContext('2d');
        const protocolChart = new Chart(protocolCtx, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    backgroundColor: [
                        '#667eea', '#764ba2', '#f093fb', '#4facfe',
                        '#43e97b', '#fa709a', '#fee140', '#30cfd0'
                    ]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        position: 'right'
                    }
                }
            }
        });

        // Rate chart (per-minute counts over last 60 minutes)
        let minuteBuckets = Array(60).fill(0);
        let lastMinute = Math.floor(Date.now() / 60000);
        const rateCtx = document.getElementById('rateChart').getContext('2d');
        const rateChart = new Chart(rateCtx, {
            type: 'line',
            data: {
                labels: Array.from({length: 60}, (_, i) => `-${59 - i}m`),
                datasets: [{
                    label: 'Packets/min',
                    data: minuteBuckets,
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Packets'
                        }
                    }
                }
            }
        });

        function rollMinuteBuckets() {
            const nowMinute = Math.floor(Date.now() / 60000);
            const diff = nowMinute - lastMinute;
            if (diff > 0) {
                if (diff >= minuteBuckets.length) {
                    minuteBuckets = Array(minuteBuckets.length).fill(0);
                } else {
                    minuteBuckets = minuteBuckets.slice(diff);
                    while (minuteBuckets.length < 60) {
                        minuteBuckets.push(0);
                    }
                }
                lastMinute = nowMinute;
                updateRateChartLabels();
            }
        }

        function updateRateChartLabels() {
            rateChart.data.labels = Array.from({length: minuteBuckets.length}, (_, i) => {
                const offset = minuteBuckets.length - 1 - i;
                return offset === 0 ? '0m' : `-${offset}m`;
            });
        }
        updateRateChartLabels();

        // Update chart regularly to account for minute rollovers
        setInterval(() => {
            rollMinuteBuckets();
            rateChart.data.datasets[0].data = minuteBuckets.slice();
            rateChart.update();
        }, 1000);

        // Socket events
        socket.on('connect', () => {
            console.log('Connected to server');
            document.getElementById('statusDot').classList.remove('disconnected');
            document.getElementById('statusText').textContent = 'Connected';
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            document.getElementById('statusDot').classList.add('disconnected');
            document.getElementById('statusText').textContent = 'Disconnected';
        });

        socket.on('new_packet', (packet) => {
            try {
                rollMinuteBuckets();
                if (minuteBuckets.length > 0) {
                    minuteBuckets[minuteBuckets.length - 1] += 1;
                }

                // Update protocol chart
                const proto = packet && packet.protocol ? packet.protocol : 'Unknown';
                if (!protocolData[proto]) {
                    protocolData[proto] = 0;
                }
                protocolData[proto]++;
                
                protocolChart.data.labels = Object.keys(protocolData);
                protocolChart.data.datasets[0].data = Object.values(protocolData);
                protocolChart.update();

                // Update rate chart immediately
                rateChart.data.datasets[0].data = minuteBuckets.slice();
                updateRateChartLabels();
                rateChart.update();

                // Add to table
                addPacketToTable(packet);
            } catch (e) {
                console.error('Error handling new_packet:', e, packet);
            }
        });

        socket.on('stats_update', (newStats) => {
            stats = newStats;
            updateStats();
        });

        socket.on('new_alert', (alert) => {
            addAlert(alert);
        });

        function updateStats() {
            document.getElementById('totalPackets').textContent = stats.totalPackets.toLocaleString();
            document.getElementById('anomalyPackets').textContent = stats.anomalyPackets.toLocaleString();
            document.getElementById('anomalyRate').textContent = stats.anomalyRate.toFixed(2) + '%';
            
            const minutes = Math.floor(stats.runtime / 60);
            const seconds = stats.runtime % 60;
            document.getElementById('runtime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function addPacketToTable(packet) {
            try {
                const table = document.getElementById('packetsTable');
                
                // Remove "waiting" message if present
                if (table.rows.length === 1 && table.rows[0].cells.length === 1) {
                    table.innerHTML = '';
                }

                const safe = (v, d='') => (v === undefined || v === null ? d : v);
                const row = table.insertRow(0);
                
                // Format source and destination with hostnames
                const srcDisplay = safe(packet.src_hostname)
                    ? `<strong>${packet.src_hostname}</strong><br><small>${safe(packet.src_ip,'')}</small>`
                    : safe(packet.src_ip,'');
                
                const dstDisplay = safe(packet.dst_hostname)
                    ? `<strong style="color: #667eea;">${packet.dst_hostname}</strong><br><small>${safe(packet.dst_ip,'')}</small>`
                    : safe(packet.dst_ip,'');
                
                // Format service/port
                const service = safe(packet.service);
                const port = safe(packet.dst_port,'');
                const serviceDisplay = service
                    ? `<strong>${service}</strong><br><small>:${port}</small>`
                    : `:${port}`;
                
                // Anomaly indicator with more info
                const anomaly = !!packet.is_anomaly;
                const anomalyBadge = anomaly 
                    ? `<span class="anomaly-badge">‚ö†Ô∏è ANOMALY</span><br><small>Score: ${safe(packet.anomaly_score, 0)}</small>` 
                    : '<span class="normal-badge">‚úì NORMAL</span>';
                
                // Threat level based on flow score
                const flow = Number(safe(packet.flow_score, 0));
                let threatDisplay = '';
                if (flow === 0) {
                    threatDisplay = '<span style="color: #27ae60;">‚óè</span> Safe';
                } else if (flow < 4) {
                    threatDisplay = '<span style="color: #f39c12;">‚óè</span> Low';
                } else if (flow < 6) {
                    threatDisplay = '<span style="color: #e67e22;">‚óè‚óè</span> Medium';
                } else {
                    threatDisplay = '<span style="color: #e74c3c;">‚óè‚óè‚óè</span> <strong>HIGH</strong>';
                }
                
                row.innerHTML = `
                    <td><strong>#${safe(packet.id,'')}</strong></td>
                    <td>${safe(packet.timestamp,'')}</td>
                    <td>${srcDisplay}</td>
                    <td>${dstDisplay}</td>
                    <td><span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.85em;">${safe(packet.protocol,'Unknown')}</span></td>
                    <td>${serviceDisplay}</td>
                    <td>${safe(packet.size,0)}B</td>
                    <td>${anomalyBadge}</td>
                    <td>${threatDisplay}</td>
                `;

                // Highlight anomalies more prominently
                if (anomaly) {
                    row.style.backgroundColor = '#ffe6e6';
                    row.style.borderLeft = '4px solid #e74c3c';
                    row.style.fontWeight = 'bold';
                }
                
                // Highlight high threat flows
                if (flow >= 6) {
                    row.style.backgroundColor = '#fff3cd';
                    row.style.borderLeft = '4px solid #f39c12';
                }

                // Keep only last 50 packets
                while (table.rows.length > 50) {
                    table.deleteRow(table.rows.length - 1);
                }
            } catch (e) {
                console.error('Error rendering packet row:', e, packet);
            }
        }

        function getFlowScoreClass(score) {
            if (score === 0) return 'flow-score-low';
            if (score < 4) return 'flow-score-low';
            if (score < 6) return 'flow-score-medium';
            return 'flow-score-high';
        }

        function addAlert(alert) {
            const alertsList = document.getElementById('alertsList');
            
            // Remove "no alerts" message
            if (alertsList.querySelector('p')) {
                alertsList.innerHTML = '';
            }

            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert-item critical';
            alertDiv.innerHTML = `
                <span class="alert-timestamp">[${alert.timestamp}]</span>
                ${alert.message}
            `;
            
            alertsList.insertBefore(alertDiv, alertsList.firstChild);

            // Keep only last 20 alerts
            while (alertsList.children.length > 20) {
                alertsList.removeChild(alertsList.lastChild);
            }
        }

        // Load initial data
        fetch('/api/stats')
            .then(r => r.json())
            .then(data => {
                stats = {
                    totalPackets: data.total_packets || 0,
                    anomalyPackets: data.anomaly_packets || 0,
                    anomalyRate: data.anomaly_rate || 0,
                    runtime: data.start_time ? Math.floor(Date.now() / 1000 - data.start_time) : 0
                };
                updateStats();
            });

        // Load recent packets so history shows even if capture already finished
        fetch('/api/packets')
            .then(r => r.json())
            .then(packets => {
                if (Array.isArray(packets)) {
                    // Oldest first, then insert to table (which prepends)
                    packets.forEach(pkt => {
                        // Protocol snapshot for static data
                        if (!protocolData[pkt.protocol]) protocolData[pkt.protocol] = 0;
                        protocolData[pkt.protocol]++;
                        addPacketToTable(pkt);
                    });
                    protocolChart.data.labels = Object.keys(protocolData);
                    protocolChart.data.datasets[0].data = Object.values(protocolData);
                    protocolChart.update();
                }
            });
    </script>
</body>
</html>
